# 피보나치 힙 복잡도 분석

## 1. 서론

피보나치 힙의 효율성은 분할상환 분석(Amortized Analysis)을 통해 증명됩니다. 이 문서는 각 연산의 시간 복잡도를 엄밀하게 분석하고, 포텐셜 방법을 사용한 분할상환 분석을 제시합니다.

## 2. 분할상환 분석 기초

### 2.1 분할상환 분석의 필요성

피보나치 힙의 일부 연산은 최악의 경우 비싸지만, 연속된 연산들의 평균 비용은 낮습니다. 예를 들어:
- EXTRACT-MIN은 때때로 O(n) 시간이 걸릴 수 있지만
- 이러한 비싼 연산은 자주 발생하지 않습니다
- 전체적으로는 O(log n) 분할상환 시간을 보장합니다

### 2.2 포텐셜 방법 (Potential Method)

포텐셜 방법은 자료구조의 "잠재 에너지"를 나타내는 포텐셜 함수 Φ를 정의합니다.

**정의**: 연산 시퀀스 O₁, O₂, ..., Oₘ에 대해
- cᵢ: i번째 연산의 실제 비용
- Φᵢ: i번째 연산 후의 포텐셜
- ĉᵢ: i번째 연산의 분할상환 비용

분할상환 비용: ĉᵢ = cᵢ + Φᵢ - Φᵢ₋₁

전체 실제 비용: ∑(i=1 to m) cᵢ = ∑(i=1 to m) ĉᵢ - (Φₘ - Φ₀)

따라서 Φₘ ≥ Φ₀이면 실제 비용 ≤ 분할상환 비용의 합

## 3. 피보나치 힙의 포텐셜 함수

### 3.1 포텐셜 함수 정의

**정의**: 피보나치 힙 H에 대해
```
Φ(H) = t(H) + 2m(H)
```

여기서:
- t(H): 힙 H의 루트 리스트에 있는 트리의 개수
- m(H): 힙 H에서 마킹된 노드의 개수

### 3.2 포텐셜 함수의 특성

**특성 1**: Φ(H) ≥ 0 (항상 음이 아님)
- t(H) ≥ 0 (트리 개수는 음이 아님)
- m(H) ≥ 0 (마킹된 노드 개수는 음이 아님)

**특성 2**: 빈 힙의 포텐셜은 0
- Φ(∅) = t(∅) + 2m(∅) = 0 + 2×0 = 0

**특성 3**: 포텐셜은 힙의 "무질서도"를 나타냄
- 더 많은 트리 = 더 높은 포텐셜 = 향후 CONSOLIDATE 작업 필요
- 더 많은 마킹 = 더 높은 포텐셜 = 향후 절단 작업 가능성

## 4. 연산별 분할상환 분석

### 4.1 INSERT 연산 분석

**알고리즘**:
1. 새 노드 생성
2. 루트 리스트에 추가
3. 필요시 min 포인터 업데이트
4. 노드 수 증가

**실제 비용**: c = O(1) (모든 단계가 상수 시간)

**포텐셜 변화**: 
- 새로운 트리 1개 추가: t(H') = t(H) + 1
- 마킹된 노드 변화 없음: m(H') = m(H)
- ΔΦ = Φ(H') - Φ(H) = (t(H) + 1) + 2m(H) - (t(H) + 2m(H)) = 1

**분할상환 비용**: ĉ = c + ΔΦ = O(1) + 1 = O(1)

### 4.2 MINIMUM 연산 분석

**알고리즘**: min 포인터 반환

**실제 비용**: c = O(1)

**포텐셜 변화**: ΔΦ = 0 (상태 변화 없음)

**분할상환 비용**: ĉ = O(1) + 0 = O(1)

### 4.3 UNION 연산 분석

**알고리즘**:
1. 두 힙의 루트 리스트 연결
2. 새로운 최솟값 결정
3. 노드 수 합산

**실제 비용**: c = O(1) (포인터 조작만 수행)

**포텐셜 변화**:
- t(H) = t(H₁) + t(H₂) (트리들이 단순히 합쳐짐)
- m(H) = m(H₁) + m(H₂) (마킹된 노드들이 보존됨)
- ΔΦ = Φ(H) - Φ(H₁) - Φ(H₂) = 0

**분할상환 비용**: ĉ = O(1) + 0 = O(1)

### 4.4 EXTRACT-MIN 연산 분석

이것이 가장 복잡한 분석입니다.

**알고리즘**:
1. 최솟값의 자식들을 루트 리스트에 추가 (D시간)
2. 최솟값을 루트 리스트에서 제거 (O(1)시간)
3. 새로운 최솟값을 임시로 설정 (O(1)시간)
4. CONSOLIDATE 수행 (핵심 부분)

#### 4.4.1 CONSOLIDATE 분석

**CONSOLIDATE 전 상태**:
- 루트 노드 개수: t(H) (원래) + D (추가된 자식들) - 1 (제거된 최솟값)
- 실제 루트 개수: t(H) + D - 1

**CONSOLIDATE 과정**:
- 각 루트를 한 번씩 처리: O(t(H) + D)
- degree가 같은 트리들을 합병
- 최종적으로 각 degree에 최대 하나의 트리만 남음
- 최대 degree는 D(n) = ⌊log_φ n⌋ = O(log n)

**CONSOLIDATE 후 상태**:
- 루트 개수: 최대 D(n) + 1 = O(log n)

**실제 비용 계산**:
```
c = O(D + t(H))
  = O(log n + t(H))  (∵ D ≤ D(n) = O(log n))
```

**포텐셜 변화 계산**:
- CONSOLIDATE 전: Φ = (t(H) + D - 1) + 2m(H)
- CONSOLIDATE 후: Φ' ≤ (D(n) + 1) + 2m(H) = O(log n) + 2m(H)
- ΔΦ = Φ' - Φ ≤ O(log n) + 2m(H) - (t(H) + D - 1) - 2m(H)
- ΔΦ ≤ O(log n) - t(H) - D + 1

**분할상환 비용**:
```
ĉ = c + ΔΦ
  ≤ O(log n + t(H)) + O(log n) - t(H) - D + 1
  = O(log n) + O(log n) - D + 1
  = O(log n)  (∵ D ≥ 0)
```

### 4.5 DECREASE-KEY 연산 분석

**알고리즘**:
1. 키 값 감소 (O(1))
2. 힙 특성 검사 (O(1))
3. 필요시 CUT 수행 (O(1))
4. CASCADING-CUT 수행

#### 4.5.1 CASCADING-CUT 분석

이것이 핵심입니다. c번의 절단(cut)이 발생한다고 가정합시다.

**실제 비용**: 
- 각 절단은 O(1) 시간
- 총 비용: c₁ = O(c)

**포텐셜 변화**:
- c개의 노드가 절단되어 새로운 루트가 됨: 트리 개수 +c
- 절단된 c개 노드 중 c-1개는 마킹이 해제됨 (마지막 하나는 원래 마킹 안됨)
- 마지막으로 절단을 유발한 노드는 마킹됨: 마킹된 노드 -c+1+1 = -c+2

더 정확한 분석:
- 절단 전에 마킹된 노드들이 절단됨: -（c-1）개 마킹 감소
- 새로운 노드 하나가 마킹됨: +1개 마킹 증가
- 순 마킹 변화: -(c-1) + 1 = -c + 2

**포텐셜 변화**:
```
ΔΦ = Δt + 2Δm
    = c + 2(-c + 2)
    = c - 2c + 4
    = 4 - c
```

**분할상환 비용**:
```
ĉ = c₁ + ΔΦ
  = O(c) + (4 - c)
  = O(c) + 4 - c
  = O(1)  (상수항이 c를 상쇄)
```

### 4.6 DELETE 연산 분석

DELETE(x) = DECREASE-KEY(x, -∞) + EXTRACT-MIN()

**분할상환 비용**:
```
ĉ = ĉ_decrease + ĉ_extract
  = O(1) + O(log n)
  = O(log n)
```

## 5. 종합 결과

| 연산 | 분할상환 시간 복잡도 |
|------|---------------------|
| MAKE-HEAP | O(1) |
| INSERT | O(1) |
| MINIMUM | O(1) |
| EXTRACT-MIN | O(log n) |
| UNION | O(1) |
| DECREASE-KEY | O(1) |
| DELETE | O(log n) |

## 6. 실제 vs 분할상환 비용

### 6.1 worst-case 시나리오

**EXTRACT-MIN의 최악의 경우**:
- n개 노드가 모두 루트인 경우
- CONSOLIDATE에서 O(n) 시간 소요
- 하지만 이런 상황은 많은 INSERT 연산 후에만 발생
- INSERT 연산들이 충분한 포텐셜을 축적

**DECREASE-KEY의 최악의 경우**:
- CASCADING-CUT이 루트까지 전파
- O(log n) 시간 소요 가능
- 하지만 많은 노드들의 마킹이 해제되어 포텐셜 감소

### 6.2 포텐셜의 역할

포텐셜 함수는 "미래의 작업을 위한 예금"으로 볼 수 있습니다:

1. **INSERT**: 포텐셜 증가 (예금)
   - 루트 개수 증가로 향후 CONSOLIDATE 작업량 증가 예상
   
2. **EXTRACT-MIN**: 포텐셜 감소 (출금)
   - CONSOLIDATE로 루트 개수 대폭 감소
   - 축적된 포텐셜을 실제 작업 비용에 사용

3. **DECREASE-KEY**: 포텐셜 변화가 작업을 상쇄
   - 절단으로 인한 트리 증가 (+포텐셜)
   - 마킹 해제로 인한 감소 (-포텐셜)
   - 순 효과는 상수

## 7. 하한 (Lower Bound) 분석

### 7.1 정보 이론적 하한

우선순위 큐의 일반적인 하한:
- n개 원소 정렬: Ω(n log n)
- EXTRACT-MIN 연산: Ω(log n) (정렬 관점에서)

### 7.2 피보나치 힙의 최적성

**정리**: 피보나치 힙은 다음 연산 조합에 대해 점근적으로 최적입니다:
- m개의 DECREASE-KEY 연산
- n개의 INSERT 연산  
- n개의 EXTRACT-MIN 연산

**증명 스케치**: 
- DECREASE-KEY가 ω(1) 시간이 필요하다면
- 전체 시간이 ω(m + n log n)이 됨
- 하지만 정렬의 하한은 Ω(n log n)이므로
- ω(m)이 추가되면 비효율적

## 8. 공간 복잡도 분석

### 8.1 노드당 공간 사용량

각 노드가 필요한 필드들:
```cpp
struct FibNode {
    Key key;           // K bytes
    void* data;        // 8 bytes (64-bit 시스템)
    FibNode* parent;   // 8 bytes
    FibNode* child;    // 8 bytes
    FibNode* left;     // 8 bytes
    FibNode* right;    // 8 bytes
    int degree;        // 4 bytes
    bool marked;       // 1 byte
    // 패딩: 3 bytes
};
```

**총 노드당 공간**: 8K + 48 bytes (K는 키 크기)

### 8.2 보조 공간

- CONSOLIDATE용 degree 배열: O(log n) 공간
- 기타 관리 구조: O(1) 공간

**총 공간 복잡도**: O(n)

## 9. 실제 성능 분석

### 9.1 상수 인수 분석

분할상환 분석은 점근적 결과만 제공합니다. 실제 상수 인수들:

- INSERT: 보통 1-2개의 포인터 조작
- EXTRACT-MIN: degree 배열 크기가 ⌊log₁.₆₁₈ n⌋ ≈ 1.44 log₂ n
- DECREASE-KEY: 평균적으로 1개의 절단

### 9.2 캐시 성능 고려

- 루트 리스트 순회: 좋은 캐시 지역성
- 트리 순회: 나쁜 캐시 지역성 (부모-자식 관계)
- CONSOLIDATE: degree 배열의 좋은 지역성

## 10. 결론

피보나치 힙의 분할상환 분석은 포텐셜 방법을 통해 엄밀하게 증명됩니다. 핵심 아이디어들:

1. **포텐셜 함수**: Φ(H) = t(H) + 2m(H)는 힙의 "무질서도"를 측정
2. **포텐셜 균형**: 비싼 연산은 포텐셜을 감소시켜 자체 비용을 상쇄
3. **상수 분할상환 비용**: INSERT, DECREASE-KEY, UNION은 O(1)
4. **로그 분할상환 비용**: EXTRACT-MIN, DELETE는 O(log n)

이러한 분석은 피보나치 힙이 그래프 알고리즘에서 이론적으로 최적임을 보여주며, 실제 구현에서도 우수한 성능을 달성할 수 있는 이론적 기반을 제공합니다.